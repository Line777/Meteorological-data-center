# 第一周学习总结
本周是开始做项目的第一周，第一感受就是难，和平时自己接触到的东西跨度太大，有些无从下手。比如本周涉及的linux的操作，已经基本都忘了，liux多进程和信号以前也没有学过，一个几十分钟的视频可能要两三个小时才能看完，就做的很艰难。
## 时间操作函数
### time库函数

time函数的用途是返回一个值，也就是从1970年1月1日0时0分0秒到现在的秒数。

time函数是C语言标准库中的函数，在time.h文件中声明。

time_t time(time_t *t);

time函数有两种调用方法：

  time_t tnow;

  tnow =time(0);     // 将空地址传递给time函数，并将time返回值赋给变量tnow
或

  time(&tnow);       // 将变量tnow的地址作为参数传递给time函数
您可以写代码测试一下这两种方式，效果完全相同。
### tm结构体
time_t只是一个长整型，不符合我们的使用习惯，需要转换成可以方便表示时间的结构体，即tm结构体，tm结构体在time.h中声明，如下：

struct tm
{
  int tm_sec;     // 秒：取值区间为[0,59] 

  int tm_min;     // 分：取值区间为[0,59] 

  int tm_hour;    // 时：取值区间为[0,23] 

  int tm_mday;    // 日期：一个月中的日期：取值区间为[1,31]

  int tm_mon;     // 月份：（从一月开始，0代表一月），取值区间为[0,11]

  int tm_year;    // 年份：其值等于实际年份减去1900

  int tm_wday;    // 星期：取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 

  int tm_yday;    // 从每年的1月1日开始的天数：取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 

  int tm_isdst;   // 夏令时标识符，该字段意义不大，我们不用夏令时。
};

这个结构定义了年、月、日、时、分、秒、星期、当年中的某一天、夏令时。用这个结构体可以很方便的显示时间。
### 程序睡眠
在实际开发中，我们经常需要把程序挂起一段时间，可以使用sleep和usleep两个库函数，需要包含unistd.h头文件中。函数的声明如下：

unsigned int sleep(unsigned int seconds);

int usleep(useconds_t usec);

sleep函数的参数是秒，usleep函数的参数是微秒，1秒=1000000微秒。

  sleep(1);           // 程序睡眠1秒。

  sleep(10);          // 程序睡眠10秒。

  usleep(100000);    // 程序睡眠十分之一秒。

  usleep(1000000);   // 程序睡眠一秒。

程序员不关心sleep和usleep函数的返回值。

sleep和wait函数的区别：

sleep和wait都会将程序挂机，但sleep进入挂起状态，占用cpu并不释放，会占用cpu但什么都不做。而wait会释放掉占用内存，进入阻塞挂起状态，在外存挂起，在需要时重新分配cpu资源
## 信号
在 Linux 系统（以及其他类 Unix 操作系统）中，信号被用于进程间的通信。信号是一个发送到某个进程或同一进程中的特定线程的异步通知，用于通知发生的一个事件。

当进程收到一个信号时，可能会发生以下 3 种情况：

进程可能会忽略此信号。有些信号不能被忽略，而有些没有默认行为的信号，默认会被忽略。

进程可能会捕获此信号，并执行一个被称为信号处理器的特殊函数。

进程可能会执行信号的默认行为。例如，信号 15(SIGTERM) 的默认行为是结束进程。

共有64种信号，其中常用Ctrl+c为终端输入的信号，编号为15，可以结束一个进程。
9号信号无法被捕获，可以强制结束进程。
## linux多进程
### fork函数
在Linux系统中创建进程有两种方式：一是由操作系统创建，二是由父进程创建进程（通常为子进程）。系统调用函数fork()是创建一个新进程的唯一方式，当然vfork()也可以创建进程，但是实际上其还是调用了fork()函数。fork()函数是Linux系统中一个比较特殊的函数，其一次调用会有两个返回值。

调用fork()之后，父进程与子进程的执行顺序是我们无法确定的（即调度进程使用CPU），意识到这一点极为重要，因为在一些设计不好的程序中会导致资源竞争，从而出现不可预知的问题。

fork产生子进程的表现就是它会返回2次，一次返回0，顺序执行下面的代码。这是子进程。一次返回子进程的pid，也顺序执行下面的代码，这是父进程。

进程创建成功之后，父进程以及子进程都从fork() 之后开始执行，知识pid不同。fork语句可以看成将程序切为A、B两个部分。（在fork()成功之后，子进程获取到了父进程的所有变量、环境变量、程序计数器的当前空间和值）。

一般来说，fork()成功之后，父进程与子进程的执行顺序是不确定的。这取决于内核所使用的调度算法，如果要求父子进程相互同步，则要求某种形式的进程间通信。
